#| 两个并行指令中
第一行，锁保护的是 计算(* x x)
第二行，锁保护的是 (set! x (+ x 1))

这里有一个坑，就是线程1计算完(* x x)后，锁就失效了
后面的set!会无视线程2的锁，此时完全可能对线程2造成影响。

所以可能出现的情况
100 (线程1取得x为10后，算出100，计算结果覆盖了线程2)
101 (线程1计算完毕后，线程2做了x+1)
121 (线程2做了x+1后，线程1计算了平方)

11 (最容易出坑的一种情况)
    线程1加锁，取得10，并计算出100
    线程1解锁
    线程2加锁，取得10，并计算出11
    线程1修改x为100（注意，此时线程1已经没有锁了，不会去理会线程2的状态）
    线程2修改x为11
    线程2解锁
 |#